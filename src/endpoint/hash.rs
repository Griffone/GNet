//! Helper module for generating, reading and validating a packet hash.

pub type Hash = u32;

use std::mem::size_of;
use std::hash::{BuildHasher, Hasher};

/// Read the hash from the packet header.
pub fn read_hash(packet: &[u8]) -> Hash {
	debug_assert!(packet.len() > size_of::<Hash>());
	debug_assert!(packet.as_ptr().align_offset(std::mem::align_of::<Hash>()) == 0);
	#[allow(clippy::cast_ptr_alignment)]
	unsafe { *(packet.as_ptr() as *const Hash) }
}

/// Generate the hash for the provided packet data.
pub fn generate_hash<H: Hasher>(packet: &[u8], mut hasher: H) -> Hash {
	debug_assert!(packet.len() > size_of::<Hash>());
	hasher.write(&packet[size_of::<Hash>() .. ]);
	hasher.finish() as Hash
}

/// Generate the hash for the provided packet data and write it into the packet header.
pub fn generate_and_write_hash<H: Hasher>(packet: &mut [u8], hasher: H) {
	debug_assert!(packet.len() > std::mem::size_of::<Hash>());
	debug_assert!(packet.as_ptr().align_offset(std::mem::align_of::<Hash>()) == 0);
	let hash = generate_hash(packet, hasher);
	unsafe { *(packet.as_mut_ptr() as *mut Hash) = hash }
}

/// Check that the hash in the provided packet header is equivalent to the one generated by provided hasher.
pub fn valid_hash<H: Hasher>(packet: &[u8], hasher: H) -> bool {
	generate_hash(packet, hasher) == read_hash(packet)
}

/// Specialized marker for stable hasher builders.
/// 
/// Stable in this case means the hashers are seeded in a constant manner
/// on separate machines. Such behavior is necessary for generating hashes
/// (checksums) for sent data and detecting erroneous network packets.
pub trait StableBuildHasher : BuildHasher {}

/// Hasher used in unit tests throughout the library.
#[cfg(test)]
pub(crate) type TestHasher = hashers::fnv::FNV1aHasher32;

#[cfg(test)]
pub(crate) struct TestHasherBuilder();

#[cfg(test)]
impl BuildHasher for TestHasherBuilder {
	type Hasher = TestHasher;
	fn build_hasher(&self) -> Self::Hasher { TestHasher::default() }
}

#[cfg(test)]
impl StableBuildHasher for TestHasherBuilder {}
