//! Helper module for generating, reading and validating a packet hash.

pub type Hash = u32;

use std::mem::size_of;
use std::hash::Hasher;

/// Read the hash from the packet header.
pub fn read_hash(packet: &[u8]) -> Hash {
	debug_assert!(packet.len() > size_of::<Hash>());
	debug_assert!(packet.as_ptr().align_offset(std::mem::align_of::<Hash>()) == 0);
	#[allow(clippy::cast_ptr_alignment)]
	unsafe { *(packet.as_ptr() as *const Hash) }
}

/// Generate the hash for the provided packet data.
pub fn generate_hash<H: Hasher>(packet: &[u8], mut hasher: H) -> Hash {
	debug_assert!(packet.len() > size_of::<Hash>());
	hasher.write(&packet[size_of::<Hash>() .. ]);
	hasher.finish() as Hash
}

/// Generate the hash for the provided packet data and write it into the packet header.
pub fn generate_and_write_hash<H: Hasher>(packet: &mut [u8], hasher: H) {
	debug_assert!(packet.len() > std::mem::size_of::<Hash>());
	debug_assert!(packet.as_ptr().align_offset(std::mem::align_of::<Hash>()) == 0);
	let hash = generate_hash(packet, hasher);
	#[allow(clippy::cast_ptr_alignment)]
	unsafe { *(packet.as_mut_ptr() as *mut Hash) = hash }
}

/// Check that the hash in the provided packet header is equivalent to the one generated by provided hasher.
pub fn valid_hash<H: Hasher>(packet: &[u8], hasher: H) -> bool {
	generate_hash(packet, hasher) == read_hash(packet)
}
